
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Gesture Controlled Eye</title>
    <style>
        body { margin: 0; padding: 0; background-color: #000; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #video-input { display: none; transform: scaleX(-1); } /* 隐藏摄像头画面 */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffcc; font-family: monospace; font-size: 24px; text-align: center;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">正在初始化视觉神经...<br><span style="font-size:14px; color:#aaa">请允许摄像头权限</span></div>
    <video id="video-input"></video>
    <canvas id="output-canvas"></canvas>

<script>
    const videoElement = document.getElementById('video-input');
    const canvasElement = document.getElementById('output-canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const loadingDiv = document.getElementById('loading');

    // 状态变量
    let eyeClosure = 0; // 0 = 睁开, 1 = 闭合
    let targetClosure = 0;
    
    // 背景星星
    const stars = [];
    for(let i=0; i<150; i++) {
        stars.push({
            x: Math.random(), 
            y: Math.random(), 
            size: Math.random() * 2, 
            alpha: Math.random()
        });
    }

    // 调整画布大小
    function resize() {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- 绘图函数 ---

    function drawBackground() {
        // 深空背景
        const grad = canvasCtx.createLinearGradient(0, 0, 0, canvasElement.height);
        grad.addColorStop(0, "#000000");
        grad.addColorStop(1, "#0a0a2a");
        canvasCtx.fillStyle = grad;
        canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);

        // 星星
        canvasCtx.fillStyle = "white";
        stars.forEach(star => {
            canvasCtx.globalAlpha = star.alpha * (0.5 + Math.random() * 0.5); // 闪烁效果
            canvasCtx.beginPath();
            canvasCtx.arc(star.x * canvasElement.width, star.y * canvasElement.height, star.size, 0, Math.PI * 2);
            canvasCtx.fill();
        });
        canvasCtx.globalAlpha = 1.0;
    }

    function drawCity() {
        // 简单的赛博朋克城市剪影
        canvasCtx.fillStyle = "#000033";
        canvasCtx.beginPath();
        const w = canvasElement.width;
        const h = canvasElement.height;
        const groundH = h * 0.75;
        
        canvasCtx.moveTo(0, h);
        canvasCtx.lineTo(0, groundH);
        
        // 随机生成一些建筑形状
        for (let x = 0; x <= w; x += 30) {
            let height = Math.sin(x * 0.01) * 50 + 50 + (x % 70); 
            canvasCtx.lineTo(x, groundH - height);
            canvasCtx.lineTo(x + 25, groundH - height);
        }
        
        canvasCtx.lineTo(w, h);
        canvasCtx.fill();

        // 建筑灯光
        canvasCtx.fillStyle = "#00ffcc";
        for (let x = 10; x < w; x += 30) {
            if (Math.random() > 0.7) {
                 let height = Math.sin(x * 0.01) * 50 + 50 + (x % 70);
                 canvasCtx.fillRect(x + 5, groundH - height + 10, 5, 5);
                 canvasCtx.fillRect(x + 15, groundH - height + 30, 5, 5);
            }
        }
    }

    function drawEye(cx, cy, width, height, closeAmount) {
        canvasCtx.save();
        
        // 1. 眼睛轮廓 (Sclera)
        canvasCtx.beginPath();
        canvasCtx.moveTo(cx - width, cy);
        // 上眼睑曲线
        canvasCtx.bezierCurveTo(cx - width/2, cy - height * 1.5, cx + width/2, cy - height * 1.5, cx + width, cy);
        // 下眼睑曲线
        canvasCtx.bezierCurveTo(cx + width/2, cy + height * 1.5, cx - width/2, cy + height * 1.5, cx - width, cy);
        canvasCtx.fillStyle = "#e0e0e0"; // 眼白
        canvasCtx.fill();
        
        // 裁剪区域，保证眼球不出界
        canvasCtx.clip();

        // 2. 虹膜 (Colorful Iris based on image)
        const irisSize = height * 0.9;
        
        // 绘制复杂的虹膜图案
        canvasCtx.beginPath();
        canvasCtx.arc(cx, cy, irisSize, 0, Math.PI * 2);
        
        // 径向渐变模拟图片中的红绿彩色
        const irisGrad = canvasCtx.createRadialGradient(cx, cy, irisSize * 0.2, cx, cy, irisSize);
        irisGrad.addColorStop(0, "#000"); // 瞳孔边缘
        irisGrad.addColorStop(0.4, "#ff0055"); // 红
        irisGrad.addColorStop(0.7, "#ffff00"); // 黄
        irisGrad.addColorStop(1, "#00ffcc"); // 青
        
        canvasCtx.fillStyle = irisGrad;
        canvasCtx.fill();

        // 瞳孔 (Pupil) - 猫眼/细长风格
        canvasCtx.fillStyle = "#000";
        canvasCtx.beginPath();
        canvasCtx.ellipse(cx, cy, irisSize * 0.15, irisSize * 0.6, 0, 0, Math.PI * 2);
        canvasCtx.fill();

        // 高光
        canvasCtx.fillStyle = "rgba(255, 255, 255, 0.8)";
        canvasCtx.beginPath();
        canvasCtx.arc(cx + irisSize*0.3, cy - irisSize*0.3, irisSize * 0.1, 0, Math.PI * 2);
        canvasCtx.fill();

        canvasCtx.restore(); // 恢复裁剪前的状态

        // 3. 眼皮 (Eyelid Animation)
        canvasCtx.save();
        canvasCtx.fillStyle = "#0a0a2a"; // 皮肤/背景色
        
        // 上眼皮下移
        let lidY = cy - height * 1.6 + (height * 1.6 * closeAmount);
        
        canvasCtx.beginPath();
        canvasCtx.rect(cx - width * 1.2, cy - height * 2, width * 2.4, height * 2); // 覆盖整个区域
        // 减去睁开的部分（这里用简单的矩形遮罩模拟闭合效果）
        // 实际上，我们直接画一个矩形从上往下盖住
        canvasCtx.clearRect(cx - width * 1.2, lidY, width * 2.4, height * 4); 
        
        // 为了更好的效果，我们需要反向画：画出眼皮遮盖的区域
        // 重置路径
        canvasCtx.beginPath();
        
        // 上眼皮
        canvasCtx.moveTo(cx - width*1.2, cy);
        canvasCtx.bezierCurveTo(cx - width/2, cy - height * 1.5, cx + width/2, cy - height * 1.5, cx + width*1.2, cy);
        canvasCtx.lineTo(cx + width*1.2, cy - height * 3);
        canvasCtx.lineTo(cx - width*1.2, cy - height * 3);
        canvasCtx.fill();

        // 动态闭合层
        let currentLidY = (cy - height * 1.5) + (height * 1.5 * closeAmount); // 闭合到底部
        canvasCtx.fillStyle = "#05051a"; // 眼皮颜色
        canvasCtx.beginPath();
        canvasCtx.rect(cx - width*1.2, cy - height*2, width*2.4, (currentLidY - (cy - height*2)));
        canvasCtx.fill();
        
        // 下眼皮也可以稍微动一点
        let bottomLidY = (cy + height * 1.5) - (height * 0.5 * closeAmount);
        canvasCtx.beginPath();
        canvasCtx.rect(cx - width*1.2, bottomLidY, width*2.4, height*2);
        canvasCtx.fill();

        canvasCtx.restore();
    }

    function render() {
        // 平滑过渡动画
        eyeClosure += (targetClosure - eyeClosure) * 0.1;

        drawBackground();
        drawCity();
        
        // 绘制中间的大眼睛
        const cx = canvasElement.width / 2;
        const cy = canvasElement.height / 2 - 50;
        const eyeW = 150;
        const eyeH = 70;
        
        drawEye(cx, cy, eyeW, eyeH, eyeClosure);
        
        requestAnimationFrame(render);
    }

    // --- MediaPipe 逻辑 ---

    function onResults(results) {
        loadingDiv.style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // 关键点: 4 (拇指指尖) 和 8 (食指指尖)
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            
            // 计算距离 (简单的欧几里得距离，未考虑Z轴)
            const distance = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + 
                Math.pow(thumbTip.y - indexTip.y, 2)
            );

            // 阈值判断：距离越近，眼睛闭合度越高
            // 0.03 认为是完全捏合，0.15 认为是完全张开
            const minInfo = 0.03;
            const maxInfo = 0.15;
            
            let closure = 1 - ((distance - minInfo) / (maxInfo - minInfo));
            // 限制在 0 到 1 之间
            targetClosure = Math.max(0, Math.min(1, closure));
        } else {
            // 没有检测到手，默认睁开
            targetClosure = 0;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    
    camera.start();
    render(); // 开始渲染循环

</script>
</body>
</html>
