<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Three.js 手势控制粒子系统</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Helvetica Neue', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-container { position: absolute; bottom: 20px; left: 20px; z-index: 2; border: 2px solid #333; border-radius: 8px; overflow: hidden; width: 160px; height: 120px; opacity: 0.8; transform: scaleX(-1); }
        video { width: 100%; height: 100%; object-fit: cover; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 24px; z-index: 10; pointer-events: none; transition: opacity 0.5s; }
        .fullscreen-btn { position: absolute; bottom: 20px; right: 20px; z-index: 10; padding: 10px 20px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); color: white; cursor: pointer; border-radius: 4px; backdrop-filter: blur(4px); transition: all 0.3s; }
        .fullscreen-btn:hover { background: rgba(255, 255, 255, 0.3); }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
                "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>
</head>
<body>

    <div id="loading">正在初始化摄像头与AI模型...</div>
    <div id="canvas-container"></div>
    <div id="video-container">
        <video id="input-video" playsinline></video>
    </div>
    <button id="fs-btn" class="fullscreen-btn">全屏模式</button>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';
        import { Hands } from 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js';
        import { Camera } from 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1630513325/camera_utils.js';

        // --- 1. 配置与变量 ---
        const PARTICLE_COUNT = 15000;
        const config = {
            shape: 'heart',
            color: '#ff0055',
            particleSize: 0.15,
            interactionStrength: 1.0,
            autoRotate: true
        };

        let scene, camera, renderer, particles, geometry, material;
        let positions = []; // 当前粒子位置
        let targetPositions = []; // 目标形状位置
        
        // 手势相关
        let handDistance = 0; // 0 = 闭合/无手, 1 = 张开
        let targetHandFactor = 0; // 平滑插值用
        let isHandDetected = false;

        // --- 2. 初始化 Three.js ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // 创建粒子纹理（程序生成圆形发光点）
            const texture = createParticleTexture();

            // 粒子系统初始化
            geometry = new THREE.BufferGeometry();
            const initialPos = new Float32Array(PARTICLE_COUNT * 3);
            
            // 初始随机分布
            for(let i=0; i<PARTICLE_COUNT * 3; i++) {
                initialPos[i] = (Math.random() - 0.5) * 50;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(initialPos, 3));

            material = new THREE.PointsMaterial({
                color: new THREE.Color(config.color),
                size: config.particleSize,
                map: texture,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // 初始化形状数据
            generateShapes();
            
            // UI 面板
            setupGUI();

            // 事件监听
            window.addEventListener('resize', onWindowResize);
            document.getElementById('fs-btn').addEventListener('click', toggleFullScreen);

            animate();
        }

        // --- 3. 形状生成逻辑 ---
        const shapes = {
            heart: [],
            sphere: [], // 代替土星主体
            torus: [],  // 代替花朵/佛像的复杂结构
            fireworks: []
        };

        function generateShapes() {
            // 1. 爱心 (Heart)
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // 使用爱心参数方程
                const t = Math.random() * Math.PI * 2;
                // 稍微随机化分布以填充内部
                const r = Math.sqrt(Math.random()) * 0.8 + 0.2; 
                
                // 3D Heart formula approximation
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 5; // 给一点厚度
                
                // 缩放
                x *= 0.5 * r; y *= 0.5 * r; z *= r;
                shapes.heart.push(x, y, z);
            }

            // 2. 土星/球体 (Sphere + Ring)
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                if (i < PARTICLE_COUNT * 0.7) {
                    // 星球主体
                    const phi = Math.acos(-1 + (2 * i) / (PARTICLE_COUNT * 0.7));
                    const theta = Math.sqrt((PARTICLE_COUNT * 0.7) * Math.PI) * phi;
                    const r = 8;
                    shapes.sphere.push(
                        r * Math.cos(theta) * Math.sin(phi),
                        r * Math.sin(theta) * Math.sin(phi),
                        r * Math.cos(phi)
                    );
                } else {
                    // 星环
                    const angle = Math.random() * Math.PI * 2;
                    const r = 12 + Math.random() * 6;
                    shapes.sphere.push(
                        r * Math.cos(angle),
                        (Math.random() - 0.5) * 0.5, // 扁平
                        r * Math.sin(angle)
                    );
                }
            }

            // 3. 花朵/复杂几何 (Torus Knot)
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI * 2;
                // Torus Knot 参数
                const p = 3, q = 7;
                const r = 5 + 2 * Math.cos(q * u);
                
                const x = r * Math.cos(p * u);
                const y = r * Math.sin(p * u);
                const z = 2 * Math.sin(q * u);
                
                // 增加一些随机散射模拟花瓣体积
                shapes.torus.push(x * 1.5, y * 1.5, z * 1.5);
            }

            // 4. 烟花 (Fireworks / Random Sphere)
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = Math.random() * 20; // 充满整个空间
                
                shapes.fireworks.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
            }

            // 设置初始目标
            setTargetShape(config.shape);
        }

        function setTargetShape(shapeKey) {
            targetPositions = shapes[shapeKey];
        }

        // --- 4. MediaPipe 手势识别 ---
        function initMediaPipe() {
            const videoElement = document.getElementById('input-video');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            
            cameraUtils.start()
                .then(() => {
                    document.getElementById('loading').style.opacity = 0;
                    setTimeout(()=> document.getElementById('loading').remove(), 500);
                })
                .catch(e => {
                    document.getElementById('loading').innerText = "摄像头启动失败，请检查权限";
                });
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                
                // 如果检测到两只手
                if (results.multiHandLandmarks.length === 2) {
                    const hand1 = results.multiHandLandmarks[0][9]; // 中指根部
                    const hand2 = results.multiHandLandmarks[1][9];
                    
                    // 计算两手距离 (简单欧几里得距离)
                    const dx = hand1.x - hand2.x;
                    const dy = hand1.y - hand2.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // 映射距离：一般两手合拢距离约0.1，张开约0.8
                    // 将其映射到 0 到 2 之间的系数
                    handDistance = THREE.MathUtils.mapLinear(distance, 0.1, 0.7, 0, 3);
                    handDistance = Math.max(0, handDistance);
                } else {
                    // 如果只有一只手，检测大拇指和食指的开合
                    const hand = results.multiHandLandmarks[0];
                    const thumb = hand[4];
                    const index = hand[8];
                    const d = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));
                    handDistance = THREE.MathUtils.mapLinear(d, 0.02, 0.2, 0, 1.5);
                }
            } else {
                isHandDetected = false;
                handDistance = 0;
            }
        }

        // --- 5. 动画循环与粒子更新 ---
        function animate() {
            requestAnimationFrame(animate);

            const positionsAttribute = geometry.attributes.position;
            const currentPos = positionsAttribute.array;
            
            // 平滑手势系数
            targetHandFactor += (handDistance - targetHandFactor) * 0.1;
            
            // 基础扩散系数 (手势控制)
            const explosionFactor = 1 + (targetHandFactor * config.interactionStrength);

            // 变形速度
            const lerpSpeed = 0.05;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // 获取目标位置
                const tx = targetPositions[ix];
                const ty = targetPositions[iy];
                const tz = targetPositions[iz];

                // 1. 形状插值 (Morphing)
                currentPos[ix] += (tx - currentPos[ix]) * lerpSpeed;
                currentPos[iy] += (ty - currentPos[iy]) * lerpSpeed;
                currentPos[iz] += (tz - currentPos[iz]) * lerpSpeed;

                // 2. 手势交互 (从中心向外扩散)
                // 简单的原理：位置 = 原始插值位置 * 膨胀系数
                // 为了更有趣，我们可以添加一些噪点或基于距离的缩放
                if (isHandDetected) {
                     currentPos[ix] *= explosionFactor;
                     currentPos[iy] *= explosionFactor;
                     currentPos[iz] *= explosionFactor;
                }
            }
            
            positionsAttribute.needsUpdate = true;
            
            // 整体旋转
            if (config.autoRotate && !isHandDetected) {
                particles.rotation.y += 0.002;
            } else if (isHandDetected) {
                // 手势控制时减慢旋转或根据手势旋转
                 particles.rotation.y += 0.0005;
            }

            renderer.render(scene, camera);
        }

        // --- 6. 辅助功能 ---
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function setupGUI() {
            const gui = new GUI({ title: "控制器" });
            
            gui.add(config, 'shape', {
                '爱心 (Heart)': 'heart',
                '土星 (Saturn)': 'sphere',
                '花朵 (Flower)': 'torus',
                '烟花 (Fireworks)': 'fireworks'
            }).name('模型形状').onChange(val => setTargetShape(val));

            gui.addColor(config, 'color').name('粒子颜色').onChange(val => {
                material.color.set(val);
            });

            gui.add(config, 'particleSize', 0.05, 0.5).name('粒子大小').onChange(val => {
                material.size = val;
            });
            
            gui.add(config, 'interactionStrength', 0.5, 5.0).name('手势强度');
            gui.add(config, 'autoRotate').name('自动旋转');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.body.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        // 启动
        initThree();
        initMediaPipe();

    </script>
</body>
</html>
