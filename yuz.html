<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¼ åŸå¥¥ - 3Däº¤äº’ç²’å­ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        
        /* UI Container */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: none; /* Let clicks pass through to canvas if needed */
        }

        /* Controls */
        .control-group {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.2s;
        }
        .control-group:hover { transform: translateY(-2px); }

        button {
            background: linear-gradient(135deg, #6e8efb, #a777e3);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            width: 100%;
            margin-bottom: 5px;
            transition: opacity 0.2s;
        }
        button:hover { opacity: 0.9; }
        button:disabled { background: #555; cursor: not-allowed; }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: none;
        }

        /* Loading & Status */
        #status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.7);
            font-size: 14px;
            pointer-events: none;
            text-align: center;
        }

        /* Webcam Preview (Small) */
        #camera-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.3);
            transform: scaleX(-1); /* Mirror */
            display: none;
            object-fit: cover;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-container">
        <div class="control-group">
            <h3>æ§åˆ¶é¢æ¿</h3>
            <button id="btn-camera">ğŸ“· å¼€å¯æ‘„åƒå¤´äº¤äº’</button>
            <button id="btn-fullscreen">â›¶ å…¨å±æ¨¡å¼</button>
        </div>
        <div class="control-group">
            <label style="display:block; margin-bottom:5px;">ç²’å­é¢œè‰²</label>
            <input type="color" id="color-picker" value="#00ffff">
        </div>
    </div>

    <div id="status">ç­‰å¾…æ“ä½œ...</div>
    <video id="camera-preview" playsinline></video>

    <script>
        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer;
        let particles, particleGeo, particleMaterial;
        let cakeGroup;
        let fontText = "Zhang Cheng Ao"; // å¦‚éœ€ä¸­æ–‡éœ€åŠ è½½æ”¯æŒä¸­æ–‡çš„jsonå­—ä½“æ–‡ä»¶
        let initialPositions = [];
        let interactionFactor = 0; // 0 = æ­£å¸¸, 1 = æ‰©æ•£
        let handDistance = 1.0; // åŒæ‰‹è·ç¦»
        let isHandsClasped = false;
        let clock = new THREE.Clock();

        // é¢œè‰²
        const params = { color: 0x00ffff };

        // --- åˆå§‹åŒ– Three.js ---
        function init() {
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // ç¯å…‰ (ä¸ºäº†è›‹ç³•æ˜¾ç¤º)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffdd00, 1, 100);
            pointLight.position.set(10, 20, 10);
            scene.add(pointLight);

            // åˆ›å»ºå†…å®¹
            createParticles();
            createProceduralCake();

            // äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onWindowResize);
            document.getElementById('color-picker').addEventListener('input', (e) => {
                params.color = new THREE.Color(e.target.value);
                if (particles) particles.material.color.set(params.color);
            });
            document.getElementById('btn-fullscreen').addEventListener('click', toggleFullScreen);
            document.getElementById('btn-camera').addEventListener('click', startCamera);

            animate();
        }

        // --- 1. åˆ›å»ºç²’å­æ–‡å­— ---
        function createParticles() {
            const loader = new THREE.FontLoader();
            // ä½¿ç”¨æ ‡å‡†å­—ä½“ (æ³¨æ„: è¯¥å­—ä½“ä¸æ”¯æŒä¸­æ–‡ï¼Œæ˜¾ç¤ºä¸­æ–‡éœ€æ›¿æ¢ä¸ºæ”¯æŒä¸­æ–‡çš„jsonæ–‡ä»¶)
            loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function (font) {
                
                const textGeo = new THREE.TextGeometry(fontText, {
                    font: font,
                    size: 15,
                    height: 2,
                    curveSegments: 10,
                    bevelEnabled: false
                });

                textGeo.center(); // å±…ä¸­
                
                // è·å–é¡¶ç‚¹ä½œä¸ºç²’å­ä½ç½®
                // ä¸ºå¢åŠ ç²’å­å¯†åº¦ï¼Œå¯ä»¥å¤šæ¬¡é‡‡æ ·æˆ–ç»†åˆ†ï¼Œè¿™é‡Œç®€å•å¤„ç†
                const points = textGeo.vertices; 
                // æ³¨æ„: æ–°ç‰ˆThreeJS TextGeometryç”Ÿæˆçš„æ˜¯BufferGeometry, ä¸Šé¢æ˜¯è€ç‰ˆå†™æ³•ã€‚
                // ä¿®æ­£ä¸ºBufferGeometryå¤„ç†:
                
                const positions = [];
                const positionAttribute = textGeo.attributes.position;
                
                // ç®€å•é‡‡æ ·ï¼šæ¯éš”å‡ ä¸ªç‚¹å–ä¸€ä¸ªï¼Œæˆ–è€…å–æ‰€æœ‰ç‚¹
                for (let i = 0; i < positionAttribute.count; i++) {
                    positions.push(
                        positionAttribute.getX(i),
                        positionAttribute.getY(i),
                        positionAttribute.getZ(i)
                    );
                    initialPositions.push({
                        x: positionAttribute.getX(i),
                        y: positionAttribute.getY(i),
                        z: positionAttribute.getZ(i),
                        // æ·»åŠ éšæœºåç§»ç”¨äºæ‰©æ•£åŠ¨ç”»
                        randX: (Math.random() - 0.5) * 200,
                        randY: (Math.random() - 0.5) * 200,
                        randZ: (Math.random() - 0.5) * 200
                    });
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

                // æè´¨
                const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
                particleMaterial = new THREE.PointsMaterial({ 
                    color: params.color, 
                    size: 0.8, 
                    map: sprite,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                particles = new THREE.Points(geometry, particleMaterial);
                scene.add(particles);
                
                document.getElementById('status').innerText = "åœºæ™¯åŠ è½½å®Œæ¯•ï¼Œè¯·ç‚¹å‡»å¼€å¯æ‘„åƒå¤´";
            });
        }

        // --- 2. åˆ›å»ºç¨‹åºåŒ–è›‹ç³• (å½“åŒæ‰‹åˆåæ—¶æ˜¾ç¤º) ---
        function createProceduralCake() {
            cakeGroup = new THREE.Group();
            
            // åº•å±‚
            const baseGeo = new THREE.CylinderGeometry(10, 10, 5, 32);
            const baseMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 }); // å·§å…‹åŠ›è‰²
            const base = new THREE.Mesh(baseGeo, baseMat);
            
            // é¡¶å±‚
            const topGeo = new THREE.CylinderGeometry(8, 8, 4, 32);
            const topMat = new THREE.MeshPhongMaterial({ color: 0xFFC0CB }); // ç²‰è‰²
            const top = new THREE.Mesh(topGeo, topMat);
            top.position.y = 4.5;

            // èœ¡çƒ›
            const candleGeo = new THREE.CylinderGeometry(0.5, 0.5, 3, 16);
            const candleMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const candle = new THREE.Mesh(candleGeo, candleMat);
            candle.position.y = 8;

            // ç«ç„° (ç®€å•é”¥ä½“)
            const flameGeo = new THREE.ConeGeometry(0.5, 1.5, 16);
            const flameMat = new THREE.MeshBasicMaterial({ color: 0xFF4500 });
            const flame = new THREE.Mesh(flameGeo, flameMat);
            flame.position.y = 10;
            flame.name = "flame"; // ç”¨äºåŠ¨ç”»

            cakeGroup.add(base, top, candle, flame);
            cakeGroup.visible = false; // åˆå§‹éšè—
            scene.add(cakeGroup);
        }

        // --- 3. åŠ¨ç”»å¾ªç¯ & äº¤äº’é€»è¾‘ ---
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // ç²’å­åŠ¨ç”»é€»è¾‘
            if (particles) {
                const positions = particles.geometry.attributes.position.array;
                
                // æ ¹æ®æ‰‹åŠ¿è®¡ç®—ç›®æ ‡çŠ¶æ€
                // interactionFactor: 0 (æ­£å¸¸æ–‡å­—) -> 1 (æ‰©æ•£/æ”¾å¤§)
                // isHandsClasped: true (æ˜¾ç¤ºè›‹ç³•)
                
                if (isHandsClasped) {
                    particles.visible = false;
                    cakeGroup.visible = true;
                    
                    // è›‹ç³•æµ®åŠ¨åŠ¨ç”»
                    cakeGroup.rotation.y += 0.01;
                    cakeGroup.position.y = Math.sin(time * 2) * 2;
                    
                    // ç«ç„°é—ªçƒ
                    const flame = cakeGroup.getObjectByName("flame");
                    if(flame) flame.scale.setScalar(0.8 + Math.random() * 0.4);

                } else {
                    particles.visible = true;
                    cakeGroup.visible = false;

                    // è®¡ç®—ç²’å­è¿åŠ¨
                    for (let i = 0; i < initialPositions.length; i++) {
                        const initPos = initialPositions[i];
                        const px = i * 3;
                        const py = i * 3 + 1;
                        const pz = i * 3 + 2;

                        // åŸºç¡€é£˜åŠ¨
                        const floatY = Math.sin(time + initPos.x * 0.05) * 1;
                        
                        // äº¤äº’é€»è¾‘ï¼š
                        // å¦‚æœåŒæ‰‹å¼ å¼€ (handDistance å¤§)ï¼Œç²’å­å‘å¤–æ‰©æ•£ (Target = initPos + rand)
                        // å¦‚æœåŒæ‰‹æ­£å¸¸ (handDistance é€‚ä¸­)ï¼Œç²’å­å›åˆ°æ–‡å­— (Target = initPos)
                        
                        // æ˜ å°„ handDistance åˆ°æ‰©æ•£ç¨‹åº¦
                        // å‡è®¾ distance 0.2 (è¿‘) åˆ° 0.8 (è¿œ)
                        let spread = Math.max(0, (handDistance - 0.2) * 3); // æ”¾å¤§ç³»æ•°
                        
                        // ç›®æ ‡ä½ç½®
                        let targetX = initPos.x * (1 + spread * 0.5) + (initPos.randX * spread);
                        let targetY = initPos.y * (1 + spread * 0.5) + (initPos.randY * spread) + floatY;
                        let targetZ = initPos.z * (1 + spread * 0.5) + (initPos.randZ * spread);

                        // çº¿æ€§æ’å€¼ (Lerp) å¹³æ»‘è¿‡æ¸¡
                        positions[px] += (targetX - positions[px]) * 0.1;
                        positions[py] += (targetY - positions[py]) * 0.1;
                        positions[pz] += (targetZ - positions[pz]) * 0.1;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                    
                    // æ•´ä½“æ—‹è½¬
                    particles.rotation.y = Math.sin(time * 0.5) * 0.1;
                }
            }

            renderer.render(scene, camera);
        }

        // --- 4. MediaPipe Hands æ‘„åƒå¤´é€»è¾‘ ---
        async function startCamera() {
            const btn = document.getElementById('btn-camera');
            btn.innerText = "æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´...";
            btn.disabled = true;
            
            const videoElement = document.getElementById('camera-preview');
            videoElement.style.display = "block";

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            await cameraUtils.start();
            btn.innerText = "æ‘„åƒå¤´è¿è¡Œä¸­";
            document.getElementById('status').innerText = "å°è¯•å¼ å¼€åŒè‡‚æˆ–åŒæ‰‹åˆå";
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
                // æ£€æµ‹åˆ°ä¸¤åªæ‰‹
                const hand1 = results.multiHandLandmarks[0];
                const hand2 = results.multiHandLandmarks[1];

                // ä½¿ç”¨æ‰‹è…•(ç´¢å¼•0)è®¡ç®—è·ç¦»
                const wrist1 = hand1[0];
                const wrist2 = hand2[0];

                // è®¡ç®—æ¬§å‡ é‡Œå¾—è·ç¦» (å±å¹•åæ ‡ç³»ï¼ŒèŒƒå›´å¤§è‡´ 0.0 - 1.0)
                const dist = Math.sqrt(
                    Math.pow(wrist1.x - wrist2.x, 2) + 
                    Math.pow(wrist1.y - wrist2.y, 2)
                );

                handDistance = dist;

                // é˜ˆå€¼åˆ¤æ–­
                // è·ç¦»å¾ˆè¿‘ -> åˆå (æ˜¾ç¤ºè›‹ç³•)
                if (dist < 0.15) {
                    isHandsClasped = true;
                    document.getElementById('status').innerText = "ğŸ‚ ç”Ÿæ—¥å¿«ä¹ï¼(åŒæ‰‹åˆå)";
                } else {
                    isHandsClasped = false;
                    // è·ç¦»è¿œ -> æ‰©æ•£
                    if (dist > 0.5) {
                        document.getElementById('status').innerText = "âœ¨ ç²’å­æ‰©æ•£ (åŒæ‰‹å¼ å¼€)";
                    } else {
                        document.getElementById('status').innerText = "ğŸ“ æ–‡å­—èšåˆ (è·ç¦»é€‚ä¸­)";
                    }
                }
            } else {
                // æœªæ£€æµ‹åˆ°åŒæ‰‹æˆ–åªæœ‰ä¸€åªæ‰‹
                handDistance = 0.2; // é»˜è®¤å€¼
                isHandsClasped = false;
                document.getElementById('status').innerText = "è¯·åœ¨æ‘„åƒå¤´å‰å±•ç¤ºåŒæ‰‹";
            }
        }

        // --- è¾…åŠ©åŠŸèƒ½ ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        // å¯åŠ¨
        init();

    </script>
</body>
</html>
